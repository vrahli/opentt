\begin{code}
{-# OPTIONS --rewriting #-}
--{-# OPTIONS --auto-inline #-}

open import Level using (Level ; 0‚Ñì ; Lift ; lift ; lower) renaming (suc to lsuc)
open import Agda.Builtin.Bool
open import Agda.Builtin.Equality
open import Agda.Builtin.Equality.Rewrite
open import Agda.Builtin.Sigma
open import Relation.Nullary
open import Relation.Unary using (Pred; Decidable)
--open import Relation.Binary.PropositionalEquality using (sym ; trans ; subst)
open import Relation.Binary.PropositionalEquality
open ‚â°-Reasoning
open import Data.Product
open import Data.Product.Properties
open import Data.Sum
open import Data.Empty
open import Data.Maybe
open import Data.Unit using (‚ä§ ; tt)
open import Data.Nat using (‚Ñï ; _<_ ; _‚â§_ ; _‚â•_ ; _‚â§?_ ; suc ; _+_ ; pred)
open import Data.Nat.Properties
open import Data.Bool using (Bool ; _‚àß_ ; _‚à®_)
open import Agda.Builtin.String
open import Agda.Builtin.String.Properties
open import Data.List
open import Data.List.Properties
open import Data.List.Relation.Unary.Any
open import Data.List.Relation.Binary.Subset.Propositional
open import Data.List.Relation.Binary.Subset.Propositional.Properties
open import Data.List.Membership.Propositional
open import Data.List.Membership.Propositional.Properties
open import Function.Bundles
open import Induction.WellFounded
open import Axiom.Extensionality.Propositional


open import util
open import calculus
open import terms
open import world
open import choice
open import choiceExt
open import choiceVal
open import compatible
open import getChoice
open import progress
open import freeze
open import newChoice
open import mod
open import choiceBar


module continuity6 {L : Level} (W : PossibleWorlds {L}) (M : Mod W)
                   (C : Choice) (K : Compatible {L} W C) (P : Progress {L} W C K) (G : GetChoice {L} W C K)
                   (X : ChoiceExt W C)
                   (N : NewChoice {L} W C K G) (V : ChoiceVal W C K G X N)
                   (F : Freeze {L} W C K P G N)
                   (E : Axiom.Extensionality.Propositional.Extensionality 0‚Ñì (lsuc(lsuc(L))))
                   (CB : ChoiceBar W M C K P G X N V F E) -- TODO - We won't need everything from there: use a different module
       where


open import worldDef(W)
open import computation(W)(C)(K)(G)(X)(N)
open import terms2(W)(C)(K)(G)(X)(N)
open import terms3(W)(C)(K)(G)(X)(N)
open import terms4(W)(C)(K)(G)(X)(N)
open import terms5(W)(C)(K)(G)(X)(N)
open import terms6(W)(C)(K)(G)(X)(N)
open import bar(W)
open import barI(W)(M)--(C)(K)(P)
open import forcing(W)(M)(C)(K)(P)(G)(X)(N)(E)
open import props0(W)(M)(C)(K)(P)(G)(X)(N)(E)
open import ind2(W)(M)(C)(K)(P)(G)(X)(N)(E)

open import choiceDef{L}(C)
open import compatibleDef{L}(W)(C)(K)
open import getChoiceDef(W)(C)(K)(G)
open import newChoiceDef(W)(C)(K)(G)(N)
open import choiceExtDef(W)(C)(K)(G)(X)
open import choiceValDef(W)(C)(K)(G)(X)(N)(V)
open import freezeDef(W)(C)(K)(P)(G)(N)(F)

open import choiceBarDef(W)(M)(C)(K)(P)(G)(X)(N)(V)(F)(E)(CB)

{--
open import type_sys_props_nat(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_qnat(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_lt(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_qlt(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_free(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_pi(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_sum(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_set(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_eq(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_union(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_tsquash(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_ffdefs(W)(M)(C)(K)(P)(G)(E)
open import type_sys_props_lift(W)(M)(C)(K)(P)(G)(E)
--}

open import props1(W)(M)(C)(K)(P)(G)(X)(N)(E)
open import props2(W)(M)(C)(K)(P)(G)(X)(N)(E)
open import props3(W)(M)(C)(K)(P)(G)(X)(N)(E)
open import props4(W)(M)(C)(K)(P)(G)(X)(N)(E)

open import continuity-conds(W)(C)(K)(G)(X)(N)

open import continuity1(W)(M)(C)(K)(P)(G)(X)(N)(V)(F)(E)(CB)
open import continuity2(W)(M)(C)(K)(P)(G)(X)(N)(V)(F)(E)(CB)
open import continuity3(W)(M)(C)(K)(P)(G)(X)(N)(V)(F)(E)(CB)
open import continuity4(W)(M)(C)(K)(P)(G)(X)(N)(V)(F)(E)(CB)
open import continuity5(W)(M)(C)(K)(P)(G)(X)(N)(V)(F)(E)(CB)



‚áõ-upd-body‚Üí‚áõ-APPLY : {name : Name} {f a : Term} {m : ‚Ñï} {w : ùïé¬∑}
                        ‚Üí # f
                        ‚Üí LET a (SEQ (updGt name (VAR 0)) (APPLY f (VAR 0))) ‚áõ NUM m at w
                        ‚Üí APPLY (upd name f) a ‚áõ NUM m at w
‚áõ-upd-body‚Üí‚áõ-APPLY {name} {f} {a} {m} {w} cf comp = ‚áõ-trans c comp
  where
    e : sub a (LET (VAR 0) (SEQ (updGt name (VAR 0)) (APPLY f (VAR 0))))
        ‚â° LET a (SEQ (updGt name (VAR 0)) (APPLY f (VAR 0)))
    e rewrite #shiftUp 0 (ct f cf)
            | subv# 2 (shiftUp 0 (shiftUp 0 (shiftUp 0 a))) f cf
            | #shiftDown 2 (ct f cf)
            | shiftDownUp a 0 = refl

    c : APPLY (upd name f) a ‚áõ LET a (SEQ (updGt name (VAR 0)) (APPLY f (VAR 0))) at w
    c w1 e1 = lift (‚áì-from-to‚Üí‚áì {w1} {w1} {APPLY (upd name f) a} {LET a (SEQ (updGt name (VAR 0)) (APPLY f (VAR 0)))}
                                 (1 , ‚Üí‚â°pair e refl))

‚áõ-force‚Üí‚áõ-APPLY : {f a : Term} {m : ‚Ñï} {w : ùïé¬∑}
                     ‚Üí # f
                     ‚Üí LET a (APPLY f (VAR 0)) ‚áõ NUM m at w
                     ‚Üí APPLY (force f) a ‚áõ NUM m at w
‚áõ-force‚Üí‚áõ-APPLY {f} {a} {m} {w} cf comp = ‚áõ-trans c comp
  where
    e : sub a (LET (VAR 0) (APPLY f (VAR 0)))
        ‚â° LET a (APPLY f (VAR 0))
    e rewrite #shiftUp 0 (ct f cf)
            | subv# 1 (shiftUp 0 (shiftUp 0 a)) f cf
            | #shiftDown 1 (ct f cf)
            | shiftDownUp a 0 = refl

    c : APPLY (force f) a ‚áõ LET a (APPLY f (VAR 0)) at w
    c w1 e1 = lift (‚áì-from-to‚Üí‚áì {w1} {w1} {APPLY (force f) a} {LET a (APPLY f (VAR 0))}
                                 (1 , ‚Üí‚â°pair e refl))


APPLY-force‚áõ : {f a : Term} {m n : ‚Ñï} {w : ùïé¬∑}
                ‚Üí # f
                ‚Üí a ‚áõ NUM n at w
                ‚Üí APPLY f (NUM n) ‚áõ NUM m at w
                ‚Üí APPLY (force f) a ‚áõ NUM m at w
APPLY-force‚áõ {f} {a} {m} {n} {w} cf comp1 comp2 =
  ‚áõ-force‚Üí‚áõ-APPLY cf (‚áõ-trans (LET‚áõ‚ÇÅ comp1) (‚áõ-trans (isValue‚ÜíLET‚áõ tt) c))
  where
    c : sub (NUM n) (APPLY f (VAR 0)) ‚áõ NUM m at w
    c rewrite #shiftUp 0 (ct f cf)
            | subv# 0 (NUM n) f cf
            | #shiftDown 0 (ct f cf) = comp2



equalInType-upd-force : (i : ‚Ñï) (w : ùïé¬∑) (name : Name) (f : CTerm)
                        ‚Üí ‚àÄùïé-get0-NUM w name
                        ‚Üí ‚ààType i w #BAIRE f
                        ‚Üí equalInType i w #BAIRE (#upd name f) (#force f)
equalInType-upd-force i w name f wgn eqf =
  equalInType-FUN eqTypesNAT eqTypesNAT aw
  where
    eqf1 : ‚àÄùïé w (Œª w' _ ‚Üí (a‚ÇÅ a‚ÇÇ : CTerm) ‚Üí equalInType i w' #NAT a‚ÇÅ a‚ÇÇ
                         ‚Üí equalInType i w' #NAT (#APPLY f a‚ÇÅ) (#APPLY f a‚ÇÇ))
    eqf1 = equalInType-FUN‚Üí eqf

    aw : ‚àÄùïé w (Œª w' _ ‚Üí (a‚ÇÅ a‚ÇÇ : CTerm) ‚Üí equalInType i w' #NAT a‚ÇÅ a‚ÇÇ
                       ‚Üí equalInType i w' #NAT (#APPLY (#upd name f) a‚ÇÅ) (#APPLY (#force f) a‚ÇÇ))
    aw w1 e1 a‚ÇÅ a‚ÇÇ eqa = ‚ÜíequalInType-NAT i w1 (#APPLY (#upd name f) a‚ÇÅ) (#APPLY (#force f) a‚ÇÇ) eqn3
      where
        eqn1 : ‚ñ°¬∑ w1 (Œª w' _ ‚Üí NATeq w' a‚ÇÅ a‚ÇÇ)
        eqn1 = equalInType-NAT‚Üí i w1 a‚ÇÅ a‚ÇÇ eqa

        eqn3a : ‚àÄùïé w1 (Œª w' e' ‚Üí NATeq w' a‚ÇÅ a‚ÇÇ ‚Üí ‚ñ°¬∑ w' (‚ÜëwPred' (Œª w'' _ ‚Üí NATeq w'' (#APPLY (#upd name f) a‚ÇÅ) (#APPLY (#force f) a‚ÇÇ)) e'))
        eqn3a w2 e2 (n , c‚ÇÅ , c‚ÇÇ) = Mod.‚àÄùïé-‚ñ°Func M aw2 eqn2
          where
            aw2 : ‚àÄùïé w2 (Œª w' e' ‚Üí NATeq w' (#APPLY f (#NUM n)) (#APPLY f (#NUM n))
                                  ‚Üí ‚ÜëwPred' (Œª w'' _ ‚Üí NATeq w'' (#APPLY (#upd name f) a‚ÇÅ) (#APPLY (#force f) a‚ÇÇ)) e2 w' e')
            aw2 w3 e3 (m , d‚ÇÅ , d‚ÇÇ) z =
              m ,
              ‚áõ-upd-body‚Üí‚áõ-APPLY {name} {‚åú f ‚åù} {‚åú a‚ÇÅ ‚åù} {m} {w3} (CTerm.closed f) (‚áõ-upd-body w3 ‚åú f ‚åù ‚åú a‚ÇÅ ‚åù n m name (‚àÄùïé-mon (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3)) wgn) (CTerm.closed f) (‚àÄùïé-mon e3 c‚ÇÅ) d‚ÇÅ) ,
              APPLY-force‚áõ (CTerm.closed f) (‚àÄùïé-mon e3 c‚ÇÇ) d‚ÇÇ

            eqf2 : equalInType i w2 #NAT (#APPLY f (#NUM n)) (#APPLY f (#NUM n))
            eqf2 = eqf1 w2 (‚äë-trans¬∑ e1 e2) (#NUM n) (#NUM n) (NUM-equalInType-NAT i w2 n)

            eqn2 : ‚ñ°¬∑ w2 (Œª w' _ ‚Üí NATeq w' (#APPLY f (#NUM n)) (#APPLY f (#NUM n)))
            eqn2 = equalInType-NAT‚Üí i w2 (#APPLY f (#NUM n)) (#APPLY f (#NUM n)) eqf2

        eqn3 : ‚ñ°¬∑ w1 (Œª w' _ ‚Üí NATeq w' (#APPLY (#upd name f) a‚ÇÅ) (#APPLY (#force f) a‚ÇÇ))
        eqn3 = Mod.‚ñ°-idem M (Mod.‚àÄùïé-‚ñ°Func M eqn3a eqn1) --‚àÄùïé-‚ñ°Func2 aw1 eqn1 eqn2



eqfg-aux : {w w1 : ùïé¬∑} (e : w ‚äë¬∑ w1) {name : Name} {f g a b c v v' : Term} {n : ‚Ñï}
           ‚Üí isValue v
           ‚Üí strongMonEq w1 a b
           ‚Üí b ‚áõ NUM n at w
           ‚Üí a ‚áì v at w1
           ‚Üí c ‚áì v' at w
           ‚Üí updRel name f g v v'
           ‚Üí c ‚áì NUM n at w
eqfg-aux {w} {w1} e {name} {f} {g} {a} {b} {c} {v} {v'} {n} isv (m , c‚ÇÅ , c‚ÇÇ) compb compa compc ur =
  concl
  where
    eqn : n ‚â° m
    eqn = NUMinj (‚áõ-val-det {w1} {b} {NUM n} {NUM m} tt tt (‚àÄùïé-mon e compb) c‚ÇÇ)

    c‚ÇÅ' : a ‚áõ NUM n at w1
    c‚ÇÅ' rewrite eqn = c‚ÇÅ

    eqv : v ‚â° NUM n
    eqv = ‚áì-val-det {w1} {a} {v} {NUM n} isv tt compa (lower (c‚ÇÅ' w1 (‚äë-refl¬∑ _)))

    ur' : updRel name f g (NUM n) v'
    ur' rewrite sym eqv = ur

    concl : c ‚áì NUM n at w
    concl rewrite sym (updRel-NUM‚Çó‚Üí ur') = compc



-- define an 'external' version of #ŒΩtestM that follows the computation of (APPLY F f), and keeps
-- track of the highest number f is applied to, and prove that this 'external' version returns
-- the same value as the 'internal' one (i.e., #ŒΩtestM)
eqfg : (cn : comp‚Üí‚àÄ‚Ñï) (kb : K‚ñ°) (gc : get-choose-‚Ñï)
      {i : ‚Ñï} {w : ùïé¬∑} {F f g : CTerm}
      ‚Üí #¬¨Names F
      ‚Üí #¬¨Names f
      ‚Üí #¬¨Names g
      ‚Üí ‚ààType i w #BAIRE‚ÜíNAT F
      ‚Üí ‚ààType i w #BAIRE f
      ‚Üí ‚ààType i w #BAIRE g
      ‚Üí equalInType i w (#BAIREn (#ŒΩtestM F f)) f g
--       ((n : ‚Ñï) ‚Üí n < ? ‚Üí ‚áìsame‚Ñï w (APPLY f (NUM n)) (APPLY g (NUM n)))
      ‚Üí equalInType i w #NAT (#APPLY F f) (#APPLY F g)
eqfg cn kb gc {i} {w} {F} {f} {g} nnF nnf nng ‚ààF ‚ààf ‚ààg eqb =
  equalInType-trans (equalInType-APPLY-force ‚ààF ‚ààf) (equalInType-trans eqf (equalInType-sym (equalInType-APPLY-force ‚ààF ‚ààg)))
  where
    neqt : NATeq w (#ŒΩtestM F f) (#ŒΩtestM F f)
    neqt = ŒΩtestM-NAT cn kb gc i w F f nnF nnf ‚ààF ‚ààf

    tn : ‚Ñï
    tn = fst neqt

    x : NATeq w (#ŒΩtestM F f) (#NUM tn)
    x = tn , fst (snd neqt) , compAllRefl _ _

    cx : #ŒΩtestM F f #‚áõ #NUM tn at w
    cx = NATeq‚Üí‚áõ {w} {#ŒΩtestM F f} x

    eqb1 : ‚àÄùïé w (Œª w' _ ‚Üí (a‚ÇÅ a‚ÇÇ : CTerm) ‚Üí equalInType i w' (#NATn (#ŒΩtestM F f)) a‚ÇÅ a‚ÇÇ
                         ‚Üí equalInType i w' #NAT (#APPLY f a‚ÇÅ) (#APPLY g a‚ÇÇ))
    eqb1 = equalInType-FUN‚Üí (‚â°CTerm‚ÜíequalInType (‚â°BAIREn (#ŒΩtestM F f)) eqb)

    eqb2 : ‚àÄùïé w (Œª w' _ ‚Üí (a‚ÇÅ a‚ÇÇ : CTerm)
                         ‚Üí ‚ñ°¬∑ w' (Œª w'' _ ‚Üí Œ£ ‚Ñï (Œª k ‚Üí a‚ÇÅ #‚áõ #NUM k at w'' √ó a‚ÇÇ #‚áõ #NUM k at w'' √ó k < tn))
                         ‚Üí ‚ñ°¬∑ w' (Œª w'' _ ‚Üí NATeq w'' (#APPLY f a‚ÇÅ) (#APPLY g a‚ÇÇ)))
    eqb2 w1 e1 a‚ÇÅ a‚ÇÇ eqa = equalInType-NAT‚Üí i w1 (#APPLY f a‚ÇÅ) (#APPLY g a‚ÇÇ) (eqb1 w1 e1 a‚ÇÅ a‚ÇÇ (‚ÜíequalInType-NATn (‚àÄùïé-mon e1 cx) eqa))

    eqb3 : ‚àÄùïé w (Œª w' _ ‚Üí (k : ‚Ñï) ‚Üí k < tn
                         ‚Üí NATeq w' (#APPLY f (#NUM k)) (#APPLY g (#NUM k)))
    eqb3 w1 e1 k ltk = kb z w1 (‚äë-refl¬∑ _)
      where
        z : ‚ñ°¬∑ w1 (Œª w'' _ ‚Üí NATeq w'' (#APPLY f (#NUM k)) (#APPLY g (#NUM k)))
        z = eqb2 w1 e1 (#NUM k) (#NUM k) (Mod.‚àÄùïé-‚ñ° M (Œª w2 e2 ‚Üí k , #compAllRefl (#NUM k) w2 , #compAllRefl (#NUM k) w2 , ltk))

    inn : ‚ààType i w #NAT (#APPLY F (#force f))
    inn = equalInType-refl (equalInType-sym (equalInType-APPLY-force ‚ààF ‚ààf))

    aw : ‚àÄùïé w (Œª w' _ ‚Üí NATeq w' (#APPLY F (#force f)) (#APPLY F (#force f))
                      ‚Üí NATeq w' (#APPLY F (#force f)) (#APPLY F (#force g)))
    aw w1 e1 (n , comp1 , comp2) = n , comp1 , ¬¨Names‚Üí‚áì‚Üí‚áõ w1 w1 ‚åú #APPLY F (#force g) ‚åù (NUM n) (#¬¨Names-APPLY {F} {#force g} nnF (#¬¨Names-force {g} nng)) compg
      where
        cxb : Œ£ ùïé¬∑ (Œª w2 ‚Üí ŒΩtestM ‚åú F ‚åù ‚åú f ‚åù ‚áì NUM tn from w1 to w2)
        cxb = ‚áì‚Üífrom-to (lower (cx w1 e1))

        w2 : ùïé¬∑
        w2 = fst cxb

        compt : ŒΩtestM ‚åú F ‚åù ‚åú f ‚åù ‚áì NUM tn from w1 to w2
        compt = snd cxb

        w1s : ùïé¬∑
        w1s = startNewChoiceT Res‚ä§ w1 (testM 0 ‚åú F ‚åù ‚åú f ‚åù)

        compu : Œ£ Name (Œª name ‚Üí Œ£ Term (Œª v ‚Üí Œ£ ‚Ñï (Œª j ‚Üí
                 APPLY ‚åú F ‚åù (upd name ‚åú f ‚åù) ‚áì v from (chooseT name w1s (NUM 0)) to w2
                 √ó isValue v
                 √ó getT 0 name w2 ‚â° just (NUM j)
                 √ó tn ‚â° suc j
                 √ó compatible¬∑ name w1s Res‚ä§)))
        compu = #ŒΩtestM‚áì‚Üí cn {w1} {w2} {‚åú F ‚åù} {‚åú f ‚åù} {tn} (CTerm.closed F) (CTerm.closed f) nnF nnf compt

        name : Name
        name = fst compu

        v : Term
        v = fst (snd compu)

        j : ‚Ñï
        j = fst (snd (snd compu))

        w1' : ùïé¬∑
        w1' = chooseT name w1s (NUM 0)

        e0' : w1 ‚äë¬∑ w1'
        e0' = ‚äë-trans¬∑ (startNewChoiceT‚äè Res‚ä§ w1 (testM 0 ‚åú F ‚åù ‚åú f ‚åù)) (choose‚äë¬∑ name w1s (T‚Üí‚ÑÇ¬∑ (NUM 0)))

        e1' : w ‚äë¬∑ w1'
        e1' = ‚äë-trans¬∑ e1 e0'

        k : ‚Ñï
        k = fst (fst (snd (snd (snd compu))))

        compa : steps k (APPLY ‚åú F ‚åù (upd name ‚åú f ‚åù) , w1') ‚â° (v , w2)
        compa = snd (fst (snd (snd (snd compu))))

        isvv : isValue v
        isvv = fst (snd (snd (snd (snd compu))))

        g0 : getT 0 name w2 ‚â° just (NUM j)
        g0 = fst (snd (snd (snd (snd (snd compu)))))

        eqj : tn ‚â° suc j
        eqj = fst (snd (snd (snd (snd (snd (snd compu))))))

        compat : compatible¬∑ name w1s Res‚ä§
        compat = snd (snd (snd (snd (snd (snd (snd compu))))))

        compat1 : compatible¬∑ name w1' Res‚ä§
        compat1 = ‚äë-compatible¬∑ (choose‚äë¬∑ name w1s (T‚Üí‚ÑÇ¬∑ (NUM 0))) compat

        wgt0 : ‚àÄùïé-get0-NUM w1' name
        wgt0 = cn name w1s 0 compat

        ish : isHighest‚Ñï {k} {w1'} {w2} {APPLY ‚åú F ‚åù (upd name ‚åú f ‚åù)} {v} tn name compa
        ish = steps-sat-isHighest‚Ñï
                gc {name} {‚åú f ‚åù} {k} nnf (CTerm.closed f) {w1'} {w2} {APPLY ‚åú F ‚åù (upd name ‚åú f ‚åù)} {v} {tn}
                compa isvv (updCtxt-APPLY ‚åú F ‚åù (upd name ‚åú f ‚åù) (¬¨Names‚ÜíupdCtxt {name} {‚åú f ‚åù} {‚åú F ‚åù} nnF) updCtxt-upd)
                compat1
                wgt0
                (j , g0 , ‚â°suc‚Üí< eqj)

        compg0 : Œ£ ‚Ñï (Œª k' ‚Üí Œ£ Term (Œª v' ‚Üí steps k' (APPLY ‚åú F ‚åù (force ‚åú g ‚åù) , w1) ‚â° (v' , w1) √ó updRel name ‚åú f ‚åù ‚åú g  ‚åù v v'))
        compg0 = steps-updRel-app gc {tn} {name} {‚åú F ‚åù} {‚åú f ‚åù} {‚åú g ‚åù} {v} {k} {w1'} {w2} {w1} nnF nnf nng (CTerm.closed f) (CTerm.closed g) compat1 wgt0 (‚àÄùïé-mon e1' eqb3) compa ish isvv

        k' : ‚Ñï
        k' = fst compg0

        v' : Term
        v' = fst (snd compg0)

        compg1 : steps k' (APPLY ‚åú F ‚åù (force ‚åú g ‚åù) , w1) ‚â° (v' , w1)
        compg1 = fst (snd (snd compg0))

        ur :  updRel name ‚åú f ‚åù ‚åú g  ‚åù v v'
        ur = snd (snd (snd compg0))

        equf : ‚àÄùïé w1' (Œª w' _ ‚Üí NATeq w' (#APPLY F (#upd name f)) (#APPLY F (#force f)))
        equf = kb (equalInType-NAT‚Üí i w1' (#APPLY F (#upd name f)) (#APPLY F (#force f)) (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w1' e1') (equalInType-upd-force i w1' name f wgt0 (equalInType-mon ‚ààf w1' e1'))))

        compg : #APPLY F (#force g) #‚áì #NUM n at w1
        compg = eqfg-aux {w1} {w1'} e0' {name} {‚åú f ‚åù} {‚åú g ‚åù} {APPLY ‚åú F ‚åù (upd name ‚åú f ‚åù)} {APPLY ‚åú F ‚åù (force ‚åú f ‚åù)} {APPLY ‚åú F ‚åù (force ‚åú g ‚åù)} {v} {v'} {n} isvv (equf w1' (‚äë-refl¬∑ _)) comp1 (‚áì-from-to‚Üí‚áì (k , compa)) (‚áì-from-to‚Üí‚áì (k' , compg1)) ur

    eqf : equalInType i w #NAT (#APPLY F (#force f)) (#APPLY F (#force g))
    eqf = ‚ÜíequalInType-NAT
            i w (#APPLY F (#force f)) (#APPLY F (#force g))
            (Mod.‚àÄùïé-‚ñ°Func M aw (equalInType-NAT‚Üí i w (#APPLY F (#force f)) (#APPLY F (#force f)) inn))



continuityBody : (cn : comp‚Üí‚àÄ‚Ñï) (kb : K‚ñ°) (gc : get-choose-‚Ñï)
             (i : ‚Ñï) (w : ùïé¬∑) (F f : CTerm)
             ‚Üí #¬¨Names F
             ‚Üí #¬¨Names f
             ‚Üí ‚ààType i w #BAIRE‚ÜíNAT F
             ‚Üí ‚ààType i w #BAIRE f
             ‚Üí ‚ààType i w (#contBody F f) (#PAIR (#ŒΩtestM F f) #lam3AX)
continuityBody cn kb gc i w F f nnF nnf ‚ààF ‚ààf =
  ‚â°CTerm‚ÜíequalInType (sym (#contBody‚â° F f)) h0
  where
    aw : ‚àÄùïé w (Œª w' _ ‚Üí SUMeq (equalInType i w' #NAT)
                                (Œª a b ea ‚Üí equalInType i w' (sub0 a (#[0]PI #[0]BAIRE
                                                                             (#[1]FUN (#[1]FFDEFS #[1]BAIRE #[1]VAR0)
                                                                                      (#[1]FUN (#[1]EQ ‚åû f ‚åü #[1]VAR0 (#[1]BAIREn #[1]VAR1))
                                                                                               (#[1]EQ (#[1]APPLY ‚åû F ‚åü ‚åû f ‚åü) (#[1]APPLY ‚åû F ‚åü #[1]VAR0) #[1]NAT))))))
                                w'
                                (#PAIR (#ŒΩtestM F f) #lam3AX)
                                (#PAIR (#ŒΩtestM F f) #lam3AX))
    aw w1 e1 =
      #ŒΩtestM F f , #ŒΩtestM F f , #lam3AX , #lam3AX ,
      testM-NAT cn kb gc i w1 F f nnF nnf (equalInType-mon ‚ààF w1 e1) (equalInType-mon ‚ààf w1 e1) ,
      #compAllRefl (#PAIR (#ŒΩtestM F f) #lam3AX) w1 ,
      #compAllRefl (#PAIR (#ŒΩtestM F f) #lam3AX) w1 ,
      eql1
      where
        ea2 : ‚àÄùïé w1 (Œª w2 e2 ‚Üí (g‚ÇÅ g‚ÇÇ : CTerm) (eg : equalInType i w2 #BAIRE g‚ÇÅ g‚ÇÇ)
                             ‚Üí equalTypes i w2
                                           (#FUN (#FFDEFS #BAIRE g‚ÇÅ) (#FUN (#EQ f g‚ÇÅ (#BAIREn (#ŒΩtestM F f))) (#EQ (#APPLY F f) (#APPLY F g‚ÇÅ) #NAT)))
                                           (#FUN (#FFDEFS #BAIRE g‚ÇÇ) (#FUN (#EQ f g‚ÇÇ (#BAIREn (#ŒΩtestM F f))) (#EQ (#APPLY F f) (#APPLY F g‚ÇÇ) #NAT))))
        ea2 w2 e2 g‚ÇÅ g‚ÇÇ eg =
          eqTypesFUN‚Üê
            (eqTypesFFDEFS‚Üê eqTypesBAIRE eg)
            (eqTypesFUN‚Üê
              (eqTypesEQ‚Üê (‚ÜíequalTypesBAIREn i w2 (#ŒΩtestM F f) (#ŒΩtestM F f) (testM-NAT cn kb gc i w2 F f nnF nnf (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2))))
                          (‚ààBAIRE‚Üí‚ààBAIREn (testM-NAT cn kb gc i w2 F f nnF nnf (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2))) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2)))
                          (‚ààBAIRE‚Üí‚ààBAIREn (testM-NAT cn kb gc i w2 F f nnF nnf (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2))) eg))
              (eqTypesEQ‚Üê eqTypesNAT
                          (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2)))
                          (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) eg)))

        eql2 : equalInType i w1 (#PI #BAIRE
                                     (#[0]FUN (#[0]FFDEFS #[0]BAIRE #[0]VAR)
                                              (#[0]FUN (#[0]EQ ‚åû f ‚åü #[0]VAR (#[0]BAIREn ‚åû #ŒΩtestM F f ‚åü))
                                                       (#[0]EQ (#[0]APPLY ‚åû F ‚åü ‚åû f ‚åü) (#[0]APPLY ‚åû F ‚åü #[0]VAR) #[0]NAT))))
                                  #lam3AX
                                  #lam3AX
        eql2 = equalInType-PI
                 (Œª w2 e2 ‚Üí eqTypesBAIRE)
                 (Œª w2 e2 g‚ÇÅ g‚ÇÇ eg ‚Üí ‚â°CTerm‚ÜíeqTypes (sym (sub0-contBodyPI-PI F f (#ŒΩtestM F f) g‚ÇÅ)) (sym (sub0-contBodyPI-PI F f (#ŒΩtestM F f) g‚ÇÇ)) (ea2 w2 e2 g‚ÇÅ g‚ÇÇ eg))
                 aw2
          where
            aw3 : ‚àÄùïé w1 (Œª w2 e2 ‚Üí (g‚ÇÅ g‚ÇÇ : CTerm) ‚Üí equalInType i w2 #BAIRE g‚ÇÅ g‚ÇÇ
                                  ‚Üí equalInType i w2 (#FUN (#FFDEFS #BAIRE g‚ÇÅ)
                                                           (#FUN (#EQ f g‚ÇÅ (#BAIREn (#ŒΩtestM F f)))
                                                                 (#EQ (#APPLY F f) (#APPLY F g‚ÇÅ) #NAT)))
                                                 (#APPLY #lam3AX g‚ÇÅ) (#APPLY #lam3AX g‚ÇÇ))
            aw3 w2 e2 g‚ÇÅ g‚ÇÇ eg =
              equalInType-FUN
                (eqTypesFFDEFS‚Üê eqTypesBAIRE (equalInType-refl eg))
                (eqTypesFUN‚Üê
                  (eqTypesEQ‚Üê (‚ÜíequalTypesBAIREn i w2 (#ŒΩtestM F f) (#ŒΩtestM F f) (testM-NAT cn kb gc i w2 F f nnF nnf (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2))))
                              (‚ààBAIRE‚Üí‚ààBAIREn (testM-NAT cn kb gc i w2 F f nnF nnf (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2))) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2)))
                              (‚ààBAIRE‚Üí‚ààBAIREn (testM-NAT cn kb gc i w2 F f nnF nnf (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2))) (equalInType-refl eg)))
                  (eqTypesEQ‚Üê eqTypesNAT
                              (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-mon ‚ààf w2 (‚äë-trans¬∑ e1 e2)))
                              (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w2 (‚äë-trans¬∑ e1 e2)) (equalInType-refl eg))))
                aw4
              where
                aw4 : ‚àÄùïé w2 (Œª w' _ ‚Üí (x‚ÇÅ x‚ÇÇ : CTerm)
                                     ‚Üí equalInType i w' (#FFDEFS #BAIRE g‚ÇÅ) x‚ÇÅ x‚ÇÇ
                                     ‚Üí equalInType i w' (#FUN (#EQ f g‚ÇÅ (#BAIREn (#ŒΩtestM F f)))
                                                               (#EQ (#APPLY F f) (#APPLY F g‚ÇÅ) #NAT))
                                                         (#APPLY (#APPLY #lam3AX g‚ÇÅ) x‚ÇÅ)
                                                         (#APPLY (#APPLY #lam3AX g‚ÇÇ) x‚ÇÇ))
                aw4 w3 e3 x‚ÇÅ x‚ÇÇ ex =
                  equalInType-FUN
                    (eqTypesEQ‚Üê (‚ÜíequalTypesBAIREn i w3 (#ŒΩtestM F f) (#ŒΩtestM F f) (testM-NAT cn kb gc i w3 F f nnF nnf (equalInType-mon ‚ààF w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))) (equalInType-mon ‚ààf w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3)))))
                                 (‚ààBAIRE‚Üí‚ààBAIREn (testM-NAT cn kb gc i w3 F f nnF nnf (equalInType-mon ‚ààF w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))) (equalInType-mon ‚ààf w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3)))) (equalInType-mon ‚ààf w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))))
                                 (‚ààBAIRE‚Üí‚ààBAIREn (testM-NAT cn kb gc i w3 F f nnF nnf (equalInType-mon ‚ààF w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))) (equalInType-mon ‚ààf w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3)))) (equalInType-refl (equalInType-mon eg w3 e3))))
                    (eqTypesEQ‚Üê eqTypesNAT
                                 (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))) (equalInType-mon ‚ààf w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))))
                                 (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w3 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 e3))) (equalInType-refl (equalInType-mon eg w3 e3))))
                    aw5
                  where
                    aw5 : ‚àÄùïé w3 (Œª w' _ ‚Üí (y‚ÇÅ y‚ÇÇ : CTerm)
                                        ‚Üí equalInType i w' (#EQ f g‚ÇÅ (#BAIREn (#ŒΩtestM F f))) y‚ÇÅ y‚ÇÇ
                                        ‚Üí equalInType i w' (#EQ (#APPLY F f) (#APPLY F g‚ÇÅ) #NAT)
                                                            (#APPLY (#APPLY (#APPLY #lam3AX g‚ÇÅ) x‚ÇÅ) y‚ÇÅ)
                                                            (#APPLY (#APPLY (#APPLY #lam3AX g‚ÇÇ) x‚ÇÇ) y‚ÇÇ))
                    aw5 w4 e4 y‚ÇÅ y‚ÇÇ ey =
                      equalInType-EQ
                        eqTypesNAT
                        concl
                      where
                        hyp : ‚ñ°¬∑ w4 (Œª w5 _ ‚Üí equalInType i w5 (#BAIREn (#ŒΩtestM F f)) f g‚ÇÅ)
                        hyp = equalInType-EQ‚Üí ey

                        ff : ‚ñ°¬∑ w3 (Œª w' _ ‚Üí FFDEFSeq g‚ÇÅ (equalInType i w' #BAIRE) w' x‚ÇÅ x‚ÇÇ)
                        ff = equalInTypeFFDEFS‚Üí ex

                        aw6 : ‚àÄùïé w4 (Œª w' e' ‚Üí equalInType i w' (#BAIREn (#ŒΩtestM F f)) f g‚ÇÅ
                                              ‚Üí ‚ÜëwPred (Œª w'' _ ‚Üí FFDEFSeq g‚ÇÅ (equalInType i w'' #BAIRE) w'' x‚ÇÅ x‚ÇÇ) e4 w' e'
                                              ‚Üí equalInType i w' #NAT (#APPLY F f) (#APPLY F g‚ÇÅ))
                        aw6 w5 e5 h1 (g , h2 , nng) = equalInType-trans cc (‚ààBAIRE‚ÜíNAT‚Üí (equalInType-mon ‚ààF w5 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 (‚äë-trans¬∑ e3 (‚äë-trans¬∑ e4 e5))))) (equalInType-sym h2))
                          where
                            h3 : equalInType i w5 (#BAIREn (#ŒΩtestM F f)) f g
                            h3 = equalInType-BAIREn-BAIRE-trans h2 h1 (testM-NAT cn kb gc i w5 F f nnF nnf (equalInType-mon ‚ààF w5 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 (‚äë-trans¬∑ e3 (‚äë-trans¬∑ e4 e5))))) (equalInType-mon ‚ààf w5 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 (‚äë-trans¬∑ e3 (‚äë-trans¬∑ e4 e5))))))

                            cc : equalInType i w5 #NAT (#APPLY F f) (#APPLY F g)
                            cc = eqfg cn kb gc {i} {w5} {F} {f} {g} nnF nnf nng
                                      (equalInType-mon ‚ààF w5 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 (‚äë-trans¬∑ e3 (‚äë-trans¬∑ e4 e5)))))
                                      (equalInType-mon ‚ààf w5 (‚äë-trans¬∑ e1 (‚äë-trans¬∑ e2 (‚äë-trans¬∑ e3 (‚äë-trans¬∑ e4 e5)))))
                                      (equalInType-refl (equalInType-sym h2))
                                      h3

                        concl : ‚ñ°¬∑ w4 (Œª w5 _ ‚Üí equalInType i w5 #NAT (#APPLY F f) (#APPLY F g‚ÇÅ))
                        concl = ‚àÄùïé-‚ñ°Func2 aw6 hyp (Mod.‚Üë‚ñ° M ff e4)

            aw2 : ‚àÄùïé w1 (Œª w2 e2 ‚Üí (g‚ÇÅ g‚ÇÇ : CTerm) ‚Üí equalInType i w2 #BAIRE g‚ÇÅ g‚ÇÇ
                                  ‚Üí equalInType i w2 (sub0 g‚ÇÅ (#[0]FUN (#[0]FFDEFS #[0]BAIRE #[0]VAR)
                                                                        (#[0]FUN (#[0]EQ ‚åû f ‚åü #[0]VAR (#[0]BAIREn ‚åû #ŒΩtestM F f ‚åü))
                                                                                 (#[0]EQ (#[0]APPLY ‚åû F ‚åü ‚åû f ‚åü) (#[0]APPLY ‚åû F ‚åü #[0]VAR) #[0]NAT))))
                                                 (#APPLY #lam3AX g‚ÇÅ) (#APPLY #lam3AX g‚ÇÇ))
            aw2 w2 e2 g‚ÇÅ g‚ÇÇ eg = ‚â°CTerm‚ÜíequalInType (sym (sub0-contBodyPI-PI F f (#ŒΩtestM F f) g‚ÇÅ)) (aw3 w2 e2 g‚ÇÅ g‚ÇÇ eg)

        eql1 : equalInType i w1 (sub0 (#ŒΩtestM F f)
                                      (#[0]PI #[0]BAIRE
                                              (#[1]FUN (#[1]FFDEFS #[1]BAIRE #[1]VAR0)
                                                       (#[1]FUN (#[1]EQ ‚åû f ‚åü #[1]VAR0 (#[1]BAIREn #[1]VAR1))
                                                                (#[1]EQ (#[1]APPLY ‚åû F ‚åü ‚åû f ‚åü) (#[1]APPLY ‚åû F ‚åü #[1]VAR0) #[1]NAT)))))
                                 #lam3AX
                                 #lam3AX
        eql1 = ‚â°CTerm‚ÜíequalInType (sym (sub0-contBodyPI F f (#ŒΩtestM F f))) eql2

    seq : ‚ñ°¬∑ w (Œª w' _ ‚Üí SUMeq (equalInType i w' #NAT)
                                (Œª a b ea ‚Üí equalInType i w' (sub0 a (#[0]PI #[0]BAIRE
                                                                             (#[1]FUN (#[1]FFDEFS #[1]BAIRE #[1]VAR0)
                                                                                      (#[1]FUN (#[1]EQ ‚åû f ‚åü #[1]VAR0 (#[1]BAIREn #[1]VAR1))
                                                                                               (#[1]EQ (#[1]APPLY ‚åû F ‚åü ‚åû f ‚åü) (#[1]APPLY ‚åû F ‚åü #[1]VAR0) #[1]NAT))))))
                                w'
                                (#PAIR (#ŒΩtestM F f) #lam3AX)
                                (#PAIR (#ŒΩtestM F f) #lam3AX))
    seq = Mod.‚àÄùïé-‚ñ° M aw

    h0 : ‚ààType i w (#SUM #NAT
                         (#[0]PI #[0]BAIRE
                                 (#[1]FUN (#[1]FFDEFS #[1]BAIRE #[1]VAR0)
                                          (#[1]FUN (#[1]EQ ‚åû f ‚åü #[1]VAR0 (#[1]BAIREn #[1]VAR1))
                                                   (#[1]EQ (#[1]APPLY ‚åû F ‚åü ‚åû f ‚åü) (#[1]APPLY ‚åû F ‚åü #[1]VAR0) #[1]NAT)))))
                   (#PAIR (#ŒΩtestM F f) #lam3AX)
    h0 = equalInType-SUM (Œª w' e' ‚Üí eqTypesNAT) (equalTypes-contBodyPI i w F F f f ‚ààF ‚ààf) seq

\end{code}
